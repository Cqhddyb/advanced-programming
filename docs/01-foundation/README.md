# 1 类和对象基础

## 1.0 预备知识

### 1.0.1 栈区
程序运行时，程序中的实体将存储在四个区域中：

1. 静态数据区：用于全局变量、static存储类的局部变量以及常量的内存分配 。如果没有显式初始化，系统将把它们初始化成0。 

2. 代码区：用于存放程序的指令，对C++程序而言，代码区存放的是所有函数代码。

3. 栈区：用于自动存储类的局部变量、函数的形式参数以及函数调用时有关信息（如：函数返回地址等）的内存分配。

4. 堆区：用于动态变量的内存分配。

注意：过深的函数嵌套或递归调用会导致栈空间的不足，也不应设置过大结构的形参或局部变量。

### 1.0.2 引用

引用一个变量相当于给这个变量取了个别名；

定义引用时一定要初始化为某个变量，不能是常量或表达式；

初始化后就一直引用该变量，不会再引用其他变量；

例如：

    double a = 4, b = 5;
    double & r1 = a;//r1类型是double &
    double & r2 = r1;
    r2 = 10;
    cout << a << endl;//10
    r1 = b;//赋值而不是引用另一个变量
    cout << a << endl;//5

思考：swap函数的写法

常引用 (加const)

    int n = 100;
    const int & r = n;
    r = 200;//编译出错，不能通过常引用修改引用的内容
    n = 200;//没问题，变量本身还是可以照常修改

并且，T和T &类型的变量可以初始化const T &类型的引用，反之则不行(除非强制类型转换)；

### 1.0.3 const关键字

1. 用途1：定义常量

2. 用途2：定义常量指针（不可以通过常量指针修改其指向的内容）

例如：

    int n, m;
    const int *p = & n;
    int *p2;
    * p = 5;//编译出错，不能通过常量指针修改指向的变量
    n = 4;//没问题，被指向的变量本身可以修改
    p = & m;//也没问题，可以指向另一个变量
    p = p2;//没问题，非常量指针可以赋值给常量指针
    p2 = p;//出错，反之不可以，因为p2改变会带来p的改变
    p2 = (int *)p1;//可以强制类型转换

函数参数定义为常量指针时，可以避免函数内部修改指针所指向的内容。

3. 用途3：定义常引用，具体见上文引用部分的介绍

### 1.0.4 动态内存分配

用new运算符实现动态内存分配

1. 分配一个变量

    P = new T; 
    delete P;

T是任意类型名，P是类型为T*的指针，动态分配出一块大小为sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。

2. 分配一个数组

    P = new T[N];
    delete [] P;

T是任意类型名，P是类型为T*的指针，N是要分配的数组元素的个数，可以是一个整型表达式。动态分配出一块大小为sizeof(T)*N的内存空间，并将该内存空间的起始地址赋值给P。

由new动态分配的内存空间要通过delete释放，同一块空间不能释放多次。

### 1.0.5 内联函数、函数重载、缺省参数

1. 内联函数：inline关键字

函数调用需要一定开销，当函数本身执行速度很快，且需要反复执行时，调用函数的开销就相对很大，而使用内联函数，编译器处理内联函数的调用语句时，会将整个函数的代码插入到调用出，从而节省函数调用的开销。

2. 函数重载：函数名字相同，参数个数或参数类型不同。函数重载使得函数命名更简单。编译器根据对应调用语句中实参的个数和类型决定具体调用哪一个函数。


## 1.1 数据的抽象和封装

对于一个程序实体而言，  
抽象是指该程序实体的外部可观察到的行为，不考虑该程序实体的内部是如何实现的。（控制复杂度）  
封装是指把该程序实体内部的具体实现细节对使用者隐藏起来，只对外提供一个接口。（信息保护）  

过程抽象：一个名字表示一个功能，忽略具体实现；  
过程封装：将具体实现隐藏起来，数据由参数获得，结果由返回值体现  
过程抽象+封装的程序实体叫做子程序，C/C++中为函数；

数据抽象：只描述数据操作以及操作之间的关系，忽略数据的具体表现形式  
数据封装：数据和操作当做一个整体实现，对数据的访问或使用只能通过特定接口  
数据抽象+封装可以实现更好的数据保护，是面向对象设计的基础，其中“对象”就体现了数据的抽象和封装。  

## 1.2 类和对象的基本概念及面向对象概述

### 1.2.1  面向对象的程序设计

#### 面向对象程序设计的特征

面向对象程序设计（Object-oriented Programming）具有以下几个特征：

1. 程序由若干对象组成，每个对象是由一些数据以及对这些数据所能实施的操作所构成的封装体；
2. 对象的特征（包含哪些数据与操作）由相应的类来描述；
3. 对数据的操作是通过向包含数据的对象发送消息（调用对象类的对外接口中的操作）来实现的；
一个类所描述的对象特征可以从其它的类继承（获得）。

注意：如果没有“继承”，则称为：基于对象的程序设计（Object-based Programming）

在面向/基于对象的程序设计中，对象/类体现了数据抽象与封装！

#### 面向程序设计的基本内容

面向对象程序设计的基本内容：

对象/类(Object&Class)   
对象是由数据及能对其实施的操作所构成的封装体。
类描述了对象的特征（包含什么类型的数据和哪些操作），实现抽象。  

对象属于值的范畴，是程序运行时刻的实体；类则属于类型的范畴，属于编译时刻的实体。  

继承(Inheritance)   
在定义一个新的类（子类、派生类）时，可以把已有类（父类、基类）的一些特征描述先包含进来，然后再定义新的特征。  

单继承与多继承  

#### 多态

多态(Polymorphism)：某一论域中的一个元素存在多种形式和解释。在程序中，多态通常体现为：

1. 一名多用：

函数名重载

操作符重载（语言预定义和用户自定义） 

2. 类属：

类属函数：一个函数能对多种类型的数据进行操作。

类属类：一个类可以描述多种类型的对象。

3. 面向对象程序特有的多态（继承机制带来的）：

对象类型的多态：子类对象既属于子类，也属于父类。 

对象标识的多态：父类的引用或指针可以引用或指向父类对象，也可以引用或指向子类对象。

消息的多态：发给父类对象的消息也可以发给子类对象，父类与子类会给出不同的解释（处理）。

#### 绑定

绑定(Binding)：确定对多态元素的某个使用是多态元素的哪一种形式。可分为静态绑定和动态绑定。

静态绑定（Static Binding）：在编译时刻确定。

动态绑定（Dynamic Binding）：在运行时刻确定。

多态带来的好处

使得程序功能扩充变得容易（程序上层代码不变，只要增加底层的具体实现即可）。

增强语言的可扩充性（如操作符重载等）

#### 面向对象程序设计和过程式程序设计的特点

影响软件开发效率和软件质量的因素主要包括： 
* 抽象（控制复杂度）
* 封装（保护信息）
* 模块化（组织和管理大型程序）
* 软件复用（缩短开发周期）
* 可维护性（延长软件寿命）
* 软件模型的自然度（缩小解题空间与问题空间之间的语义间隙，实现从问题到解决方案的自然过渡）

过程式程序设计特点：

* 以功能为中心，强调过程（功能）抽象，但数据与操作分离，二者联系松散。
* 实现了操作的封装，但数据是公开的，数据缺乏保护。
* 按子程序划分模块，模块边界模糊。
* 子程序往往针对某个程序而设计，这使得程序难以复用。
* 功能易变，程序维护困难。
* 基于子程序的解题方式与问题空间缺乏对应。

面向对象程序设计特点：

* 以数据为中心，强调数据抽象，操作依附于数据，二者联系紧密。
* 实现了数据的封装，加强了数据的保护。
* 按对象类划分模块，模块边界清晰。
* 对象类往往具有通用性，再加上继承机制，使得程序容易复用。
* 对象类相对稳定，有利于程序维护。
* 基于对象交互的解题方式与问题空间有很好的对应

### 1.2.2 对象与类

对象构成了面向对象程序的基本计算单位，而对象的特征则由相应的类来描述。对象是用类来创建的，因此，程序中首先要定义类。

C++的类是一种用户自定义类型，定义形式如下：

    class <类名> { <成员描述> } ;

成员包括：数据成员和成员函数。类成员标识符的作用域为整个类定义范围。

#### 数据成员

数据成员是对类的对象所包含的数据描述，它们可以是常量和变量，类型可以是任意的C++类型（void除外）,甚至可以是另一个类，这时该数据成员被称为成员对象。成员对象跟随包含它的对象一起创建或消亡。

注意：在类中说明一个数据成员的类型时，如果未见到相应类型的定义，或相应的类型未定义完，则该数据成员的类型只能是这些类型的指针或引用类型。例如：

    class A;//A是在程序其它地方定义的类，这里是声明。
    class B
    {	A a; //Error，未见A的定义。
        B b; //Error，B还未定义完，递归了！
        A *p;  //OK
        B *q;  //OK
        A &aa; //OK
        B &bb; //OK
    }; 

#### 成员函数

成员函数是对类定义中的数据成员所能实施的操作描述。可在类中或类外定义。类的成员函数名是可以重载的。

#### 类成员的访问控制

* public:访问不受控制

* private：只能在本类或友元中访问

* protected：只能在本类、派生类和友元中访问

默认访问控制类型是private，对象在进入相应变量的生存期时创建，通过变量名来标识和访问。相应变量的生存期结束时，对象消亡。对象可分为：全局对象、局部对象和成员对象。

创建对象的方式：

直接方式：

    A a;

间接方式：

    A *p; p = new A;

#### 对象的操作

在类的外部，通过对象来访问类的成员时要受到类成员访问控制的限制。

例如：

    class A
    { public:
        void f() 
        { ...... //允许访问：x,y,f,g,h 
        A a;
        ...//可以访问a.x、a.y、a.f、a.g和a.h嘛？   可以。因为在类A内部。
        }
    private:
        int x;
        void g() 
        { ...... //允许访问：x,y,f,g,h 
        }
    protected:
        int y;
        void h()
        { ...... //允许访问：x,y,f,g,h
        }
    };
    void func()
    {  A a;
    a.f();  //OK
    a.x = 1;  //Error
    a.g();  //Error
    a.y = 1;  //Error
    a.h();  //Error
    ......
    }

同类对象可以赋值，默认是把一个对象的数据成员分别赋值给另一个对象的对应数据成员。

取对象地址、对象作为参数传给函数时与其他数据类型类似。

注意：对象作为函数的返回值时，函数是否包含&符会有很大不同。

    Date f(Date &d)
    { d.print(); //输出：2020.2.20
    return d;  //创建一个临时对象作为返回值，用d对其初始化
    }
    Date& g(Date &d)
    { d.print(); //输出：2020.2.20
    return d;  //不创建新对象，把对象d作为返回值
    }
    Date some_day; //创建一个日期对象
    some_day.set(2020,2,20); 
    f(some_day).set(2017,3,13); some_day.print(); //?   还是2020.2.20，因为修改的是临时对象
    g(some_day).set(2017,3,13); some_day.print(); //?    变为2017.3.13，因为修改的是some_day这个对象

## 1.3 this指针

先看一段代码：

    class A
    {	public:
            void g(int i) { x = i; };
            ...... //其它成员函数
        private:
            int x,y,z;
    };
    A a,b;  
    a.g(1); b.g(2);

函数g怎么知道x是a的还是b的呢？

类的每一个成员函数（静态成员函数除外）都有一个隐藏的形参this，其类型为该类对象的指针；在成员函数中对类成员的访问是通过this来进行的。例如，
对于前面A类的成员函数g：

	void g(int i) { x = i; }
编译程序将会把它编译成：

	void g(A *const this, int i) 	{ this->x = i; };

当通过对象访问类的成员函数时，将会把相应对象的地址传给成员函数的this参数。例如，
对于下面的成员函数调用：

	a.g(1); 和 b.g(2);
编译程序将会把它编译成： 

	g(&a,1); 和 g(&b,2);

再看一个C++程序的例子：

    class A
    {  int x,y;
    public:
    void f();
    void g(int i) { x = i; f(); }
    }；
    ......
    A a,b;
    a.f();
    a.g(1);
    b.f();
    b.g(2);

我们可以写出与上面这个程序功能等价的C程序：

    struct A
    { int x,y;
    };
    void f_A(struct A *this);
    void g_A(struct A *this, int i)
    { this->x = i;
    f_A(this);
    }
    ......
    struct A a,b;
    f_A(&a);
    g_A(&a,1);
    f_A(&b);
    g_A(&b,2);

结论：
* 面向对象是一种程序设计思想，用任何语言都可以实现！
* 采用面向对象语言会使得面向对象程序设计更加容易，语言也能提供更多的面向对象保障！

## 1.4 构造函数和析构函数

## 1.5 拷贝构造函数

## 1.6 练习
