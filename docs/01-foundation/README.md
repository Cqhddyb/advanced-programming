# 1 类和对象基础

## 1.0 预备知识

### 1.0.1 栈区
程序运行时，程序中的实体将存储在四个区域中：

1. 静态数据区：用于全局变量、static存储类的局部变量以及常量的内存分配 。如果没有显式初始化，系统将把它们初始化成0。 

2. 代码区：用于存放程序的指令，对C++程序而言，代码区存放的是所有函数代码。

3. 栈区：用于自动存储类的局部变量、函数的形式参数以及函数调用时有关信息（如：函数返回地址等）的内存分配。

4. 堆区：用于动态变量的内存分配。

注意：过深的函数嵌套或递归调用会导致栈空间的不足，也不应设置过大结构的形参或局部变量。

### 1.0.2 引用

引用一个变量相当于给这个变量取了个别名；

定义引用时一定要初始化为某个变量，不能是常量或表达式；

初始化后就一直引用该变量，不会再引用其他变量；

例如：

    double a = 4, b = 5;
    double & r1 = a;//r1类型是double &
    double & r2 = r1;
    r2 = 10;
    cout << a << endl;//10
    r1 = b;//赋值而不是引用另一个变量
    cout << a << endl;//5

思考：swap函数的写法

常引用 (加const)

    int n = 100;
    const int & r = n;
    r = 200;//编译出错，不能通过常引用修改引用的内容
    n = 200;//没问题，变量本身还是可以照常修改

并且，T和T &类型的变量可以初始化const T &类型的引用，反之则不行(除非强制类型转换)；

### 1.0.3 const关键字

1. 用途1：定义常量

2. 用途2：定义常量指针（不可以通过常量指针修改其指向的内容）

例如：

    int n, m;
    const int *p = & n;
    int *p2;
    * p = 5;//编译出错，不能通过常量指针修改指向的变量
    n = 4;//没问题，被指向的变量本身可以修改
    p = & m;//也没问题，可以指向另一个变量
    p = p2;//没问题，非常量指针可以赋值给常量指针
    p2 = p;//出错，反之不可以，因为p2改变会带来p的改变
    p2 = (int *)p1;//可以强制类型转换

函数参数定义为常量指针时，可以避免函数内部修改指针所指向的内容。

3. 用途3：定义常引用，具体见上文引用部分的介绍

### 1.0.4 动态内存分配

用new运算符实现动态内存分配

1. 分配一个变量

    P = new T; 
    delete P;

T是任意类型名，P是类型为T*的指针，动态分配出一块大小为sizeof(T)字节的内存空间，并且将该内存空间的起始地址赋值给P。

2. 分配一个数组

    P = new T[N];
    delete [] P;

T是任意类型名，P是类型为T*的指针，N是要分配的数组元素的个数，可以是一个整型表达式。动态分配出一块大小为sizeof(T)*N的内存空间，并将该内存空间的起始地址赋值给P。

由new动态分配的内存空间要通过delete释放，同一块空间不能释放多次。

### 1.0.5 内联函数、函数重载、缺省参数

1. 内联函数：inline关键字

函数调用需要一定开销，当函数本身执行速度很快，且需要反复执行时，调用函数的开销就相对很大，而使用内联函数，编译器处理内联函数的调用语句时，会将整个函数的代码插入到调用出，从而节省函数调用的开销。

2. 函数重载：函数名字相同，参数个数或参数类型不同。函数重载使得函数命名更简单。编译器根据对应调用语句中实参的个数和类型决定具体调用哪一个函数。

---

## 1.1 数据的抽象和封装

对于一个程序实体而言，  
抽象是指该程序实体的外部可观察到的行为，不考虑该程序实体的内部是如何实现的。（控制复杂度）  
封装是指把该程序实体内部的具体实现细节对使用者隐藏起来，只对外提供一个接口。（信息保护）  

过程抽象：一个名字表示一个功能，忽略具体实现；  
过程封装：将具体实现隐藏起来，数据由参数获得，结果由返回值体现  
过程抽象+封装的程序实体叫做子程序，C/C++中为函数；

数据抽象：只描述数据操作以及操作之间的关系，忽略数据的具体表现形式  
数据封装：数据和操作当做一个整体实现，对数据的访问或使用只能通过特定接口  
数据抽象+封装可以实现更好的数据保护，是面向对象设计的基础，其中“对象”就体现了数据的抽象和封装。  

---

## 1.2 类和对象的基本概念及面向对象概述

### 1.2.1  面向对象的程序设计

#### 面向对象程序设计的特征

面向对象程序设计（Object-oriented Programming）具有以下几个特征：

1. 程序由若干对象组成，每个对象是由一些数据以及对这些数据所能实施的操作所构成的封装体；
2. 对象的特征（包含哪些数据与操作）由相应的类来描述；
3. 对数据的操作是通过向包含数据的对象发送消息（调用对象类的对外接口中的操作）来实现的；
一个类所描述的对象特征可以从其它的类继承（获得）。

注意：如果没有“继承”，则称为：基于对象的程序设计（Object-based Programming）

在面向/基于对象的程序设计中，对象/类体现了数据抽象与封装！

#### 面向程序设计的基本内容

面向对象程序设计的基本内容：

对象/类(Object&Class)   
对象是由数据及能对其实施的操作所构成的封装体。
类描述了对象的特征（包含什么类型的数据和哪些操作），实现抽象。  

对象属于值的范畴，是程序运行时刻的实体；类则属于类型的范畴，属于编译时刻的实体。  

继承(Inheritance)   
在定义一个新的类（子类、派生类）时，可以把已有类（父类、基类）的一些特征描述先包含进来，然后再定义新的特征。  

单继承与多继承  

#### 多态

多态(Polymorphism)：某一论域中的一个元素存在多种形式和解释。在程序中，多态通常体现为：

1. 一名多用：

函数名重载

操作符重载（语言预定义和用户自定义） 

2. 类属：

类属函数：一个函数能对多种类型的数据进行操作。

类属类：一个类可以描述多种类型的对象。

3. 面向对象程序特有的多态（继承机制带来的）：

对象类型的多态：子类对象既属于子类，也属于父类。 

对象标识的多态：父类的引用或指针可以引用或指向父类对象，也可以引用或指向子类对象。

消息的多态：发给父类对象的消息也可以发给子类对象，父类与子类会给出不同的解释（处理）。

#### 绑定

绑定(Binding)：确定对多态元素的某个使用是多态元素的哪一种形式。可分为静态绑定和动态绑定。

静态绑定（Static Binding）：在编译时刻确定。

动态绑定（Dynamic Binding）：在运行时刻确定。

多态带来的好处

使得程序功能扩充变得容易（程序上层代码不变，只要增加底层的具体实现即可）。

增强语言的可扩充性（如操作符重载等）

#### 面向对象程序设计和过程式程序设计的特点

影响软件开发效率和软件质量的因素主要包括： 
* 抽象（控制复杂度）
* 封装（保护信息）
* 模块化（组织和管理大型程序）
* 软件复用（缩短开发周期）
* 可维护性（延长软件寿命）
* 软件模型的自然度（缩小解题空间与问题空间之间的语义间隙，实现从问题到解决方案的自然过渡）

过程式程序设计特点：

* 以功能为中心，强调过程（功能）抽象，但数据与操作分离，二者联系松散。
* 实现了操作的封装，但数据是公开的，数据缺乏保护。
* 按子程序划分模块，模块边界模糊。
* 子程序往往针对某个程序而设计，这使得程序难以复用。
* 功能易变，程序维护困难。
* 基于子程序的解题方式与问题空间缺乏对应。

面向对象程序设计特点：

* 以数据为中心，强调数据抽象，操作依附于数据，二者联系紧密。
* 实现了数据的封装，加强了数据的保护。
* 按对象类划分模块，模块边界清晰。
* 对象类往往具有通用性，再加上继承机制，使得程序容易复用。
* 对象类相对稳定，有利于程序维护。
* 基于对象交互的解题方式与问题空间有很好的对应

### 1.2.2 对象与类

对象构成了面向对象程序的基本计算单位，而对象的特征则由相应的类来描述。对象是用类来创建的，因此，程序中首先要定义类。

C++的类是一种用户自定义类型，定义形式如下：

    class <类名> { <成员描述> } ;

成员包括：数据成员和成员函数。类成员标识符的作用域为整个类定义范围。

#### 数据成员

数据成员是对类的对象所包含的数据描述，它们可以是常量和变量，类型可以是任意的C++类型（void除外）,甚至可以是另一个类，这时该数据成员被称为成员对象。成员对象跟随包含它的对象一起创建或消亡。

注意：在类中说明一个数据成员的类型时，如果未见到相应类型的定义，或相应的类型未定义完，则该数据成员的类型只能是这些类型的指针或引用类型。例如：

    class A;//A是在程序其它地方定义的类，这里是声明。
    class B
    {	A a; //Error，未见A的定义。
        B b; //Error，B还未定义完，递归了！
        A *p;  //OK
        B *q;  //OK
        A &aa; //OK
        B &bb; //OK
    }; 

#### 成员函数

成员函数是对类定义中的数据成员所能实施的操作描述。可在类中或类外定义。类的成员函数名是可以重载的。

#### 类成员的访问控制

* public:访问不受控制

* private：只能在本类或友元中访问

* protected：只能在本类、派生类和友元中访问

默认访问控制类型是private，对象在进入相应变量的生存期时创建，通过变量名来标识和访问。相应变量的生存期结束时，对象消亡。对象可分为：全局对象、局部对象和成员对象。

创建对象的方式：

直接方式：

    A a;

间接方式：

    A *p; p = new A;

#### 对象的操作

在类的外部，通过对象来访问类的成员时要受到类成员访问控制的限制。

例如：

    class A
    { public:
        void f() 
        { ...... //允许访问：x,y,f,g,h 
        A a;
        ...//可以访问a.x、a.y、a.f、a.g和a.h嘛？   可以。因为在类A内部。
        }
    private:
        int x;
        void g() 
        { ...... //允许访问：x,y,f,g,h 
        }
    protected:
        int y;
        void h()
        { ...... //允许访问：x,y,f,g,h
        }
    };
    void func()
    {  A a;
    a.f();  //OK
    a.x = 1;  //Error
    a.g();  //Error
    a.y = 1;  //Error
    a.h();  //Error
    ......
    }

同类对象可以赋值，默认是把一个对象的数据成员分别赋值给另一个对象的对应数据成员。

取对象地址、对象作为参数传给函数时与其他数据类型类似。

注意：对象作为函数的返回值时，函数是否包含&符会有很大不同。

    Date f(Date &d)
    { d.print(); //输出：2020.2.20
    return d;  //创建一个临时对象作为返回值，用d对其初始化
    }
    Date& g(Date &d)
    { d.print(); //输出：2020.2.20
    return d;  //不创建新对象，把对象d作为返回值
    }
    Date some_day; //创建一个日期对象
    some_day.set(2020,2,20); 
    f(some_day).set(2017,3,13); some_day.print(); //?   还是2020.2.20，因为修改的是临时对象
    g(some_day).set(2017,3,13); some_day.print(); //?    变为2017.3.13，因为修改的是some_day这个对象

---

## 1.3 this指针

先看一段代码：

    class A
    {	public:
            void g(int i) { x = i; };
            ...... //其它成员函数
        private:
            int x,y,z;
    };
    A a,b;  
    a.g(1); b.g(2);

函数g怎么知道x是a的还是b的呢？

类的每一个成员函数（静态成员函数除外）都有一个隐藏的形参this，其类型为该类对象的指针；在成员函数中对类成员的访问是通过this来进行的。例如，
对于前面A类的成员函数g：

	void g(int i) { x = i; }
编译程序将会把它编译成：

	void g(A *const this, int i) 	{ this->x = i; };

当通过对象访问类的成员函数时，将会把相应对象的地址传给成员函数的this参数。例如，
对于下面的成员函数调用：

	a.g(1); 和 b.g(2);
编译程序将会把它编译成： 

	g(&a,1); 和 g(&b,2);

再看一个C++程序的例子：

    class A
    {  int x,y;
    public:
    void f();
    void g(int i) { x = i; f(); }
    }；
    ......
    A a,b;
    a.f();
    a.g(1);
    b.f();
    b.g(2);

我们可以写出与上面这个程序功能等价的C程序：

    struct A
    { int x,y;
    };
    void f_A(struct A *this);
    void g_A(struct A *this, int i)
    { this->x = i;
    f_A(this);
    }
    ......
    struct A a,b;
    f_A(&a);
    g_A(&a,1);
    f_A(&b);
    g_A(&b,2);

结论：
* 面向对象是一种程序设计思想，用任何语言都可以实现！
* 采用面向对象语言会使得面向对象程序设计更加容易，语言也能提供更多的面向对象保障！

---

## 1.4 构造函数和析构函数

### 1.4.1 构造函数

当一个对象创建时，它将获得一块存储空间，该存储空间用于存储对象的数据成员。在使用对象前，需要对对象存储空间中的数据成员进行初始化。C++提供了一种对象初始化的机制：构造函数

它是类的特殊成员函数，名字与类名相同、无返回值类型。创建对象时，构造函数会被自动调用。

构造函数可以重载，其中，不带参数的（或所有参数都有默认值的）构造函数被称为默认构造函数。在创建对象时，如果没有指定调用对象类中哪一个构造函数，则调用默认构造函数初始化。也可以显式地指定调用对象类的某个构造函数。

    class A
    {		......
        public:
            A();
            A(int i);
            A(char *p);
    };
    ......
    A a1; //调用默认构造函数。也可写成：A a1=A(); 但不能写成：A a1();
    A a2(1); //调用A(int i)。也可写成：A a2=A(1); 或 A a2=1; 
    A a3("abcd");    //调A(char *)。也可写成：A a3=A("abcd") 或 A a3="abcd"; 
    A a[4];    //调用对象a[0]、a[1]、a[2]、a[3]的默认构造函数。
    A b[5]={A(),A(1),A("abcd"),2,"xyz"};     //调用b[0]的A()、b[1]的A(int)、b[2]的A(char *)、b[3]的A(int)和b[4]的A(char *)
    A *p1=new A;     //调用默认构造函数
    A *p2=new A(2);     //调用A(int i)
    A *p3=new A("xyz");    //调用A(char *)
    A *p4=new A[20];   //创建动态对象数组时，只能调用各对象的默认构造函数

构造函数也可以创建临时对象，并且对象创建之后，不能再次调用构造函数。

#### 常量和引用数据成员的初始化

对于常量和引用数据成员，不能在说明它们时初始化，也不能采用赋值操作在构造函数中对它们初始化，而是需要使用成员初始化表。例如： 

    class A 
    {	int x;
        const int y=1;   //Error
        int &z=x;     //Error
    public:
        A()
        { x = 0;    //OK
            y = 1;    //Error  
            z = & x;  //Error    
            z = x;  //Error   
        }
    };

    class A
    {  int x;
        const int y;
        int& z;
    public:
        A(): z(x),y(1)  //成员初始化表
        { x = 0;
        }
    };

在成员初始化表中，成员的书写次序并不决定它们的初始化次序，它们的初始化次序由它们在类定义中的描述次序来决定。

### 1.4.2 析构函数

在类中可以定义一个特殊的成员函数：析构函数，它的名字为“~<类名>”，没有返回类型、不带参数、不能被重载。例如：

    class A 
    {   ......
    public:
        ......
        ~A(); //析构函数
    }; 

一个对象消亡时，系统在收回它的内存空间之前，将会自动调用对象类中的析构函数，可以在析构函数中完成对象被删除前的一些清理工作。

一般情况下，类中不需要自定义析构函数，但如果对象创建后，自己又额外申请了资源（如：额外申请了内存空间），则可以自定义析构函数来归还它们。析构函数可以显式调用，这时并不是让对象消亡，而是暂时归还对象额外申请的资源。

#### 成员对象的初始化和消亡

在创建包含成员对象的对象时，除了会自动调用本身类的构造函数外，还会自动去调用成员对象类的构造函数。通常是调用成员对象类的默认构造函数。如果要调用成员对象类的非默认构造函数，需要在包含成员对象的对象类的构造函数成员初始化表中显式指出！

包含成员对象的对象消亡时，除了会自动调用本身类的析构函数外，还会自动去调用成员对象类的析构函数。

*** 注意：成员对象初始化和消亡的次序 ***

> 创建包含成员对象的对象时，先执行成员对象类的构造函数，再执行本对象类的构造函数。

> 若包含多个成员对象，这些成员对象的构造函数执行次序则按它们在本对象类中的说明次序进行。  

> 从实现上说，是先调用本身类的构造函数，但在进入函数体之前，会去调用成员对象类的构造函数，然后再执行本身类构造函数的函数体！也就是说，构造函数的成员初始化表（即使没显式给出）中有对成员对象类的构造函数的调用代码。

注意：如果类中未提供任何构造函数，但它包含成员对象，则编译程序会隐式地为之提供一个默认构造函数，其作用就是调用成员对象类的构造函数!

> 对象消亡时，先执行本身类的析构函数，再执行成员对象类的析构函数。

> 如果有多个成员对象，则成员对象析构函数的执行次序则按它们在本对象类中的说明次序的逆序进行。

> 从实现上说，是先调用本身类的析构函数，本身类析构函数的函数体执行完之后，再去调用成员对象类的析构函数！也就是说，析构函数的函数体最后有对成员对象类的析构函数的调用代码！

注意：如果类中未提供析构函数，但它包含成员对象，则编译程序会隐式地为之提供一个析构函数，其作用就是调用成员对象类的析构函数。

## 1.5 拷贝构造函数

若一个构造函数的参数类型为本类的引用，则称它为拷贝构造函数。

在三种情况下，会调用类的拷贝构造函数：
创建对象时显式指出。例如：

    A a1; 
    A a2(a1);  //创建对象a2，用对象a1初始化对象a2

把对象作为值参数传给函数时。例如：

    void f(A x) { ...... };
    ......
    A a;
    f(a);  //创建形参对象x，用对象a对x进行初始化。

把对象作为函数的返回值时。例如：

    A f() 
    {	A a;
        ......
        return a; //创建一个临时对象，用对象a对创建的临时对象进行初始化。
    }

#### 隐式拷贝构造函数

在程序中，如果没有为某个类提供拷贝构造函数，则编译器将会为其生成一个隐式拷贝构造函数。

隐式拷贝构造函数将逐个成员进行拷贝初始化

* 对于非对象成员：它采用通常的拷贝操作；

* 对于成员对象：则调用成员对象类的拷贝构造函数来对成员对象进行初始化。（递归定义！）

例如：

    class A
    {	  int x,y;
        public:
        A() { x = y = 0; }
        ......
    };
    class B
    {	  int z;
        A a;
    public:
        B() { z = 0; }
        ...... //其中没有定义拷贝构造函数
    };
    ...
    B b1; //b1.z以及b1.a.x和b1.a.y均为0。
    B b2(b1); //b2.z初始化成b1.z；调用A的拷贝构造函数用b1.a对b2.a初始化

#### 自定义拷贝构造函数

先看一段代码：

    class String
    {	   int len;
        char *str;
        public:
            String(char *s) 
            { len = strlen(s); 
            str = new char[len+1]; 
            strcpy(str,s); 
            }
            ~String() { delete []str; len=0; str=NULL; }
    };
    ......
    String s1("abcd");
    String s2(s1);

注意，系统提供的隐式拷贝构造函数将会使得s1和s2的成员指针str指向同一块内存区域！它带来的问题是：

* 如果对一个对象（s1或s2）操作之后修改了这块空间的内容，则另一个对象将会受到影响。如果不是设计者特意所为，这将是一个隐藏的错误。

* 当对象s1和s2消亡时，将会分别去调用它们的析构函数，这会使得同一块内存区域将被归还两次，从而导致程序运行错误。

* 当对象s1和s2中有一个消亡，另一个还没消亡时，则会出现使用已被归还的空间问题！

解决方法：

隐式拷贝构造函数实现的是一种浅拷贝（shallow copy），为了解决上面的问题，可以在类String中显式定义一个拷贝构造函数来实现深拷贝（deep copy）

    String::String(const String& s)
    {	len = s.len;
        str = new char[len+1];
        strcpy(str,s.str);
    }

注意：自定义的拷贝构造函数默认调用的是成员对象类的默认构造函数来对成员对象初始化！

例如：

    class A
    {		int x,y;
        public:
            A() { x = y = 0; }
            void inc() { x++; y++; }
    };
    class B
    {    int z;
        A a;
    public:
        B() { z = 0; }
        B(const B& b)  { z = b.z; }
        void inc() { z++; a.inc(); }
    };
    ...
    B b1;  /b1.z、b1.a.x和b1.a.y均为0
    b1.inc();  //b1.z、b1.a.x和b1.a.y均变成了1
    B b2(b1); //b2.z为1，b2.a.x和b2.a.y均为0

为了让b2和b1各个数据成员都一样，需要在成员初始化表中显式指出。

    B(const B& b)：a(b.a) { z = b.z; }
    B b2(b1); //b2.z为1，b2.a.x和b2.a.y均为1

## 1.6 练习
